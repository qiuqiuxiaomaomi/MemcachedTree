# MemcachedTree
Memcached缓存技术研究


![](https://i.imgur.com/so3vgS5.png)

<pre>
      通常情况下，一个内存管理算法锁通常需要考虑的问题就是内存的碎片化：在长时间地分配及回
   收之后，被系统所使用的内存趋向于散落在不连续的空间中，这使得系统很难找到连续内存空间，一
   方面增大了内存分配失败的概率，另一方面也使得分配工作变得更复杂，降低了运行效率。

      为了解决这个问题，Memcached使用了一种叫Slab的结构，在该分配算法中，内存将按照1MB的
   大小分为页，而该页则会继续分隔为一系列具有相同大小的内存块；

      因此,Memcached并不是直接根据需要记录的数据的大小来直接分配相应大小的内存。在一条新的
   记录到来时，Memcached会首先检查该记录的大小，并根据记录的大小选择记录所需要存储到的Slab
   类型。接下来，Memcached就会检查其内部锁包含的该类型Slab。如果这些Slab中有空余的块，那么
   Memcached就会使用该块记录这条信息。如果已经没有slab拥有空闲的具有合适大小的块，那么
   Memcached就会创建一个新的页，并将该页按照目标Slab类型进行划分。

      一个需要考虑的特殊情况是对记录的更新，在对一个记录进行更新的时候，记录的大小可能会发
   生改变。这种情况下，其所对应的Slab类型也可能发生变化。因此在更新时，记录在内存中的位置可能
   发生变化。

      但是需要注意的是，由于默认情况下Memcached中每页的大小为1MB，因此其单个块最大为1MB
   。除此之外，Memcached还限制每个数据所对应的键的长度不能超过250个字节。

      一般来说，Slab中各个块的大小以及块大小的递增倍数可能会对记录所载位置的选择及内存利
   用率有很大的影响。例如在当前的实现下，各个Slab中块的大小默认情况下是按照1.25倍的方式来
   递增的。也就是说，在一个Memcached实例中，某种类型Slab所提供的块的大小是80K，而提供稍
   大一点空间的Slab类型所提供的块的大小就将是100K。如果现在我们需要插入一条81K的记录，那
   么Memcached就会选择具有100K块大小的Slab，并尝试找到一个具有空闲块的Slab以存入该记录。
 
     同时您也需要注意到，我们使用的是100K块大小的Slab来记录具有81K大小的数据，因此记录该
   数据所导致的内存浪费是19K，即19%的浪费。而在需要存储的各条记录的大小平均分布的情况下，
   这种内存浪费的幅度也在9%左右。该幅度实际上取决于我们刚刚提到的各个Slab中块大小的递增
   倍数。在Memcached的初始实现中，各个Slab块的递增倍数在默认情况下是2，而不是现在的
   1.25，从而导致了平均25%左右的内存浪费。而在今后的各个版本中，该递增倍数可能还会发生
   变化，以优化Memcached的实际性能
</pre>

![](https://i.imgur.com/ulqWeaL.png)

<pre>
Memcached集群中的一致性Hash
</pre>

![](https://i.imgur.com/UkogFuH.png)

<pre>
Memcached集群部署方案
</pre>

